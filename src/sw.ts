import {
  cleanupOutdatedCaches,
  precacheAndRoute,
  createHandlerBoundToURL,
} from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, NetworkOnly, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import Dexie from 'dexie';

declare let self: ServiceWorkerGlobalScope;

// Clean up old caches and activate immediately
cleanupOutdatedCaches();
self.skipWaiting();
clientsClaim();

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);

// ---------------------------------------------------------------------------
// Navigation Fallback (SPA Support)
// ---------------------------------------------------------------------------
// Route navigation requests to index.html for SPA to work offline
let handler;
try {
  // Try to use the precached index.html
  handler = createHandlerBoundToURL('/index.html');
} catch (error) {
  // Fallback for dev mode or when index.html isn't precached
  // This prevents the "Uncaught non-precached-url" error in development
  handler = new NetworkFirst();
}

const navigationRoute = new NavigationRoute(handler, {
  denylist: [
    // Exclude URLs starting with /_ (e.g. API)
    new RegExp('^/_'),
    // Exclude URLs containing a dot (e.g. images, css, js)
    new RegExp('/[^/?]+\\.[^/]+$'),
  ],
});
registerRoute(navigationRoute);

// ---------------------------------------------------------------------------
// Runtime Caching Configuration
// ---------------------------------------------------------------------------

// Cache Google Fonts
registerRoute(
  ({ url }) =>
    url.origin.includes('googleapis.com') || url.origin.includes('gstatic.com'),
  new CacheFirst({
    cacheName: 'google-fonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache CDNs (unpkg, jsdelivr, etc.)
registerRoute(
  ({ url }) =>
    url.origin.includes('unpkg.com') || url.origin.includes('jsdelivr.net'),
  new CacheFirst({
    cacheName: 'cdn-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache Images & Icons (covers Landing Page & About Page assets)
registerRoute(
  ({ request, url }) =>
    request.destination === 'image' ||
    url.pathname.match(/\.(png|jpg|jpeg|svg|gif|webp|ico)$/),
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100, // Cache up to 100 images
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache Video Files (mp4, webm) - CRITICAL for offline landing/about page
registerRoute(
  ({ request, url }) =>
    request.destination === 'video' || url.pathname.endsWith('.mp4'),
  new CacheFirst({
    cacheName: 'video-assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200],
      }),
      new ExpirationPlugin({
        maxEntries: 15, // Limit number of videos
        maxAgeSeconds: 60 * 60 * 24 * 14, // 2 weeks
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Don't cache API calls to Supabase (let the application handle offline logic via TanStack Query / Dexie)
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkOnly()
);

// ---------------------------------------------------------------------------
// Background Sync Logic (Ported from public/sw.js)
// ---------------------------------------------------------------------------

const SYNC_TAG = 'sync-pending-reports';
const MAX_RETRY_ATTEMPTS = 3;

// Initialize Dexie
class OfflineReportsDB extends Dexie {
  reports!: Dexie.Table<any, number>;

  constructor() {
    super('CitiznOfflineDB');
    this.version(1).stores({
      reports: '++id, syncStatus, createdAt, userId',
    });
  }
}

const db = new OfflineReportsDB();
let supabaseConfig: any = null;

// Helper: Convert Blob[] to File[]
function blobsToFiles(blobs: Blob[], photoNames: string[] = []): File[] {
  if (!blobs || blobs.length === 0) return [];

  return blobs.map((blob, index) => {
    const name =
      photoNames && photoNames[index]
        ? photoNames[index]
        : `photo_${index}.jpg`;
    return new File([blob], name, { type: blob.type || 'image/jpeg' });
  });
}

// Helper: Upload photos
async function uploadPhotos(
  photos: File[],
  supabaseUrl: string,
  supabaseKey: string,
  authToken: string
) {
  if (!photos || photos.length === 0) return [];

  const uploadedUrls: string[] = [];
  const bucket = 'issue-images';

  for (const photo of photos) {
    try {
      const fileExt = photo.name.split('.').pop() || 'jpg';
      const fileName = `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`;

      const uploadResponse = await fetch(
        `${supabaseUrl}/storage/v1/object/${bucket}/${fileName}`,
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${authToken}`,
            apikey: supabaseKey,
            'x-upsert': 'false',
          },
          body: photo,
        }
      );

      if (!uploadResponse.ok) {
        const errorText = await uploadResponse.text();
        throw new Error(
          `Upload failed: ${uploadResponse.status} - ${errorText}`
        );
      }

      const publicUrl = `${supabaseUrl}/storage/v1/object/public/${bucket}/${fileName}`;
      uploadedUrls.push(publicUrl);
    } catch (error) {
      throw error;
    }
  }

  return uploadedUrls;
}

// Helper: Submit Report
async function submitReport(
  report: any,
  supabaseUrl: string,
  supabaseKey: string,
  authToken: string
) {
  try {
    const categoryMapping: Record<string, string> = {
      pothole: 'pothole',
      streetlight: 'street_lighting',
      'water-supply': 'water_supply',
      'traffic-light': 'traffic_signal',
      drainage: 'drainage',
      'road-damage': 'sidewalk',
      other: 'other',
    };

    const mappedCategory =
      categoryMapping[report.issueData.category] || 'other';
    const photos = blobsToFiles(report.photos || [], report.photoNames || []);

    let imageUrls: string[] = [];
    if (photos.length > 0 && authToken) {
      imageUrls = await uploadPhotos(
        photos,
        supabaseUrl,
        supabaseKey,
        authToken
      );
    }

    // Get reporter ID
    let reporterId = null;
    if (authToken && report.userId) {
      try {
        const profileResponse = await fetch(
          `${supabaseUrl}/rest/v1/profiles?user_id=eq.${report.userId}&select=id`,
          {
            headers: {
              apikey: supabaseKey,
              Authorization: `Bearer ${authToken}`,
              'Content-Type': 'application/json',
            },
          }
        );

        if (profileResponse.ok) {
          const profiles = await profileResponse.json();
          if (profiles && profiles.length > 0) {
            reporterId = profiles[0].id;
          }
        }
      } catch (error) {
        throw new Error('Failed to fetch user profile.');
      }
    }

    if (!reporterId) {
      throw new Error(
        `User profile not found for user_id: ${report.userId || 'undefined'}`
      );
    }

    const issueData = {
      title: report.issueData.title,
      description: report.issueData.description,
      category: mappedCategory,
      severity: report.issueData.severity,
      address: report.issueData.address,
      location_lat: report.issueData.location_lat,
      location_lng: report.issueData.location_lng,
      reporter_id: reporterId,
      image_urls: imageUrls,
    };

    const response = await fetch(`${supabaseUrl}/rest/v1/issues`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        apikey: supabaseKey,
        Authorization: `Bearer ${authToken}`,
        Prefer: 'return=representation',
      },
      body: JSON.stringify(issueData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API error: ${response.status} - ${errorText}`);
    }

    return await response.json();
  } catch (error) {
    throw error;
  }
}

// Sync Logic
async function syncPendingReports() {
  try {
    const allClients = await self.clients.matchAll({
      includeUncontrolled: true,
    });
    const hasActiveClients = allClients.some((client: any) => {
      return (
        client.focused ||
        (client.visibilityState && client.visibilityState === 'visible')
      );
    });

    if (hasActiveClients) {
      return { success: true, synced: 0, failed: 0, skipped: true };
    }

    if (!supabaseConfig) {
      allClients.forEach(client => {
        client.postMessage({ type: 'REQUEST_CONFIG' });
      });
      return { success: false, error: 'Configuration missing' };
    }

    const pendingReports = await db.reports
      .where('syncStatus')
      .anyOf(['pending', 'failed'])
      .filter((report: any) => (report.syncAttempts || 0) < MAX_RETRY_ATTEMPTS)
      .toArray();

    if (pendingReports.length === 0) {
      return { success: true, synced: 0, failed: 0 };
    }

    const { url: supabaseUrl, key: supabaseKey, authToken } = supabaseConfig;
    let syncedCount = 0;
    let failedCount = 0;

    for (const report of pendingReports) {
      if (report.syncAttempts >= MAX_RETRY_ATTEMPTS) {
        await db.reports.delete(report.id);
        failedCount++;
        continue;
      }

      try {
        await db.reports.update(report.id, {
          syncStatus: 'syncing',
          syncAttempts: (report.syncAttempts || 0) + 1,
          lastSyncAttempt: new Date().toISOString(),
        });

        await submitReport(report, supabaseUrl, supabaseKey, authToken);
        await db.reports.delete(report.id);
        syncedCount++;
      } catch (error: any) {
        const errorMessage = error.message || 'Unknown error';
        const currentReport = await db.reports.get(report.id);
        const currentAttempts = currentReport?.syncAttempts || 0;

        if (currentAttempts >= MAX_RETRY_ATTEMPTS) {
          await db.reports.delete(report.id);
        } else {
          await db.reports.update(report.id, {
            syncStatus: 'failed',
            syncError: errorMessage,
            lastSyncAttempt: new Date().toISOString(),
          });
        }
        failedCount++;
      }
    }

    allClients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        result: { success: true, synced: syncedCount, failed: failedCount },
      });
    });

    return { success: true, synced: syncedCount, failed: failedCount };
  } catch (error: any) {
    return { success: false, error: error.message || 'Unknown error' };
  }
}

// Event Listeners
self.addEventListener('sync', (event: any) => {
  if (event.tag === SYNC_TAG) {
    event.waitUntil(syncPendingReports());
  }
});

self.addEventListener('message', event => {
  if (event.data) {
    if (event.data.type === 'UPDATE_CONFIG') {
      supabaseConfig = event.data.config;
    } else if (event.data.type === 'SYNC_NOW') {
      syncPendingReports().then(result => {
        if (event.ports && event.ports[0]) {
          event.ports[0].postMessage({ success: true, result });
        }
      });
    }
  }
});
